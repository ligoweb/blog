[{"title":"gulp学习笔记","date":"2017-04-20T00:10:36.000Z","path":"2017/04/20/2017-04-20-gulp学习笔记/","text":"gulp是一个前端构建工具，与grunt相比，gulp无需写一大堆繁杂的配置参数，API也非常简单，学习起来很容易，而且gulp使用的是node.js中stream来读取和操作数据，其速度更快。 1、gulp的安装首先确保已经正确安装了node.js环境，然后以全局方式安装gulp: 1npm install -g gulp 全局安装gulp后需要在项目目录再单独安装一次 1npm install gulp --save-dev 2、建立gulpfile.js文件就像grunt需要一个Gruntfile.js文件一样，gulp也需要一个文件作为它的主文件，在gulp中的这个文件叫做gulpfile.js。在项目根目录下新建一个文件名为gulpfile.js的文件。之后要做的事情就是在gulpfile.js文件中定义我们的任务了。下面是一个最简单的gulpfile.js文件内容示例，它定义了一个默认的任务。 1234567891011const gulp = require(&apos;gulp&apos;); // 引入gulp模块const babel = require(&apos;gulp-babel&apos;); // 引入babel木块// gulp.task（）定义任务gulp.task(&apos;default&apos;, () =&gt; gulp.src(&apos;src/*.js&apos;) // gulp.src() 加载目标文件 .pipe(babel(&#123; presets: [&apos;env&apos;] &#125;)) // node中的pipe事件流机制，这里先进行babel编译 .pipe(gulp.dest(&apos;dist&apos;)) // 这里定义编译后的路径); 上面示例中定义了一个默认任务，我们在命令端执行gulp命令就会执行编译任务，如上面示例将会将src文件夹下的js文件编译成ES5文件并放置在dist文件夹下。 3、gulp中的API介绍 gulp有四个基本的API：gulp.src(), gulp.task(), gulp.dest(), gulp.watch() 3.1 gulp.src()gulp.src(globs[, options]) globs参数是文件匹配模式，用来匹配文件路径（包括文件名）。当有多个匹配模式时，该参数可以为一个数组。options为可选参数。例如 1234client/ a.js bob.js bad.js 下面的表达式可以匹配a.js和bad.js: gulp.src([&#39;client/*.js&#39;, &#39;!client/b*.js&#39;, &#39;client/bad.js&#39;]) 3.2 gulp.dest()gulp.dest()方法是用来写文件的，其语法为： gulp.dest(path[,options]) path为写入文件的路径options为一个可选参数对象。要想使用好gulp.dest()这个方法，就要理解给它传入的路径参数与最终生成的文件的关系。gulp的使用流程一般是这样子的：首先通过gulp.src()方法获取到我们想要处理的文件流，然后把文件流通过pipe方法导入到gulp的插件中，最后把经过插件处理后的流再通过pipe方法导入到gulp.dest()中，gulp.dest()方法则把流中的内容写入到文件中，这里首先需要弄清楚的一点是，我们给gulp.dest()传入的路径参数，只能用来指定要生成的文件的目录，而不能指定生成文件的文件名，它生成文件的文件名使用的是导入到它的文件流自身的文件名，所以生成的文件名是由导入到它的文件流决定的，即使我们给它传入一个带有文件名的路径参数，然后它也会把这个文件名当做是目录名，例如： 12345gulp.src(&apos;./client/templates/*.jade&apos;) .pipe(jade()) .pipe(gulp.dest(&apos;./build/templates&apos;)) .pipe(minify()) .pipe(gulp.dest(&apos;./build/minified_templates&apos;)); 3.3 gulp.task()gulp.task()方法用来定义任务，内部使用的是Orchestrator,其语法为：1gulp.task(name[, deps], fn) name为任务名deps是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数。fn为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。 gulp中执行多个任务可以通过任务依赖来实现。例如想要执行one,two,three这三个任务，那我们就可以定义一个空的任务，然后把那三个任务当做这个空的任务的依赖就行了： 12// 只要执行default任务，就相当于把one,two,three这三个任务执行了gulp.task(&apos;default&apos;, [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]); 如果任务相互之间没有依赖，任务会按你书写的顺序来执行，如果有依赖的话则会先执行依赖的任务。但是如果某个任务所依赖的任务是异步的，就要注意了，gulp并不会等待那个所依赖的异步任务完成，而是会接着执行后续的任务。例如： 12345678910gulp.task(&apos;one&apos;,function()&#123; // one是一个异步执行的任务 setTimeout(function()&#123; console.log(&apos;one is done&apos;) &#125;,5000); &#125;);// two任务虽然依赖于one任务，但是并不会等到one任务中的异步操作完成后再执行gulp.task(&apos;two&apos;, [&apos;one&apos;], function()&#123; console.log(&apos;two is done&apos;); &#125;); 上面的例子中我们执行two任务时，会先执行one任务，但不会去等待one任务中的异步操作完成后再执行two任务，而是紧接着执行two任务。所以two任务会在one任务中的异步操作完成之前就执行了。 那如果我们想要等待异步任务中的异步操作完成后再执行后续的任务，该怎么做呢？有三种方法可以实现：第一：在异步操作完成后执行一个回调函数来通知gulp这个异步任务已经完成,这个回调函数就是任务函数的第一个参数。 123456789101112gulp.task(&apos;one&apos;,function(cb)&#123; //cb为任务函数提供的回调，用来通知任务已经完成 //one是一个异步执行的任务 setTimeout(function()&#123; console.log(&apos;one is done&apos;); cb(); //执行回调，表示这个异步任务已经完成 &#125;,5000);&#125;);//这时two任务会在one任务中的异步操作完成后再执行gulp.task(&apos;two&apos;,[&apos;one&apos;],function()&#123; console.log(&apos;two is done&apos;);&#125;); 第二：定义任务时返回一个流对象。适用于任务就是操作gulp.src获取到的流的情况。 12345678910gulp.task(&apos;one&apos;,function(cb)&#123; var stream = gulp.src(&apos;client/**/*.js&apos;) .pipe(dosomething()) //dosomething()中有某些异步操作 .pipe(gulp.dest(&apos;build&apos;)); return stream;&#125;);gulp.task(&apos;two&apos;,[&apos;one&apos;],function()&#123; console.log(&apos;two is done&apos;);&#125;); 第三：返回一个promise对象，例如 12345678910111213var Q = require(&apos;q&apos;); //一个著名的异步处理的库 https://github.com/kriskowal/qgulp.task(&apos;one&apos;,function(cb)&#123; var deferred = Q.defer(); // 做一些异步操作 setTimeout(function() &#123; deferred.resolve(); &#125;, 5000); return deferred.promise;&#125;);gulp.task(&apos;two&apos;,[&apos;one&apos;],function()&#123; console.log(&apos;two is done&apos;);&#125;); gulp.task()就这些了，主要是要知道当依赖是异步任务时的处理。 3.4 gulp.watch()gulp.watch()用来监视文件的变化，当文件发生变化后，我们可以利用它来执行相应的任务，例如文件压缩等。其语法为 gulp.watch(glob[, opts], tasks) glob 为要监视的文件匹配模式，规则和用法与gulp.src()方法中的glob相同。opts 为一个可选的配置对象，通常不需要用到tasks 为文件变化后要执行的任务，为一个数组 1234567gulp.task(&apos;uglify&apos;,function()&#123; //do something&#125;);gulp.task(&apos;reload&apos;,function()&#123; //do something&#125;);gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]); gulp.watch()还有另外一种使用方式： gulp.watch(glob[, opts, cb]) glob和opts参数与第一种用法相同cb参数为一个函数。每当监视的文件发生变化时，就会调用这个函数,并且会给它传入一个对象，该对象包含了文件变化的一些信息，type属性为变化的类型，可以是added,changed,deleted；path属性为发生变化的文件的路径 1234gulp.watch(&apos;js/**/*.js&apos;, function(event)&#123; console.log(event.type); //变化类型 added为新增,deleted为删除，changed为改变 console.log(event.path); //变化的文件的路径&#125;); 4、一些常用的gulp插件gulp的插件数量虽然没有grunt那么多，但也可以说是应有尽有了，下面列举一些常用的插件。 4.1 自动加载插件使用gulp-load-plugins安装：npm install --save-dev gulp-load-plugins要使用gulp的插件，首先得用require来把插件加载进来，如果我们要使用的插件非常多，那我们的gulpfile.js文件开头可能就会是这个样子的： 1234567891011var gulp = require(&apos;gulp&apos;), //一些gulp插件,abcd这些命名只是用来举个例子 a = require(&apos;gulp-a&apos;), b = require(&apos;gulp-b&apos;), c = require(&apos;gulp-c&apos;), d = require(&apos;gulp-d&apos;), e = require(&apos;gulp-e&apos;), f = require(&apos;gulp-f&apos;), g = require(&apos;gulp-g&apos;), //更多的插件... z = require(&apos;gulp-z&apos;); 虽然这没什么问题，但会使我们的gulpfile.js文件变得很冗长，看上去不那么舒服。gulp-load-plugins插件正是用来解决这个问题。gulp-load-plugins这个插件能自动帮你加载package.json文件里的gulp插件。例如假设你的package.json文件里的依赖是这样的: 12345678&#123; &quot;devDependencies&quot;: &#123; &quot;gulp&quot;: &quot;~3.6.0&quot;, &quot;gulp-rename&quot;: &quot;~1.2.0&quot;, &quot;gulp-ruby-sass&quot;: &quot;~0.4.3&quot;, &quot;gulp-load-plugins&quot;: &quot;~0.5.1&quot; &#125;&#125; 然后我们可以在gulpfile.js中使用gulp-load-plugins来帮我们加载插件： 123var gulp = require(&apos;gulp&apos;);//加载gulp-load-plugins插件，并马上运行它var plugins = require(&apos;gulp-load-plugins&apos;)(); 然后我们要使用gulp-rename和gulp-ruby-sass这两个插件的时候，就可以使用plugins.rename和plugins.rubySass来代替了,也就是原始插件名去掉gulp-前缀，之后再转换为驼峰命名。实质上gulp-load-plugins是为我们做了如下的转换 12plugins.rename = require(&apos;gulp-rename&apos;);plugins.rubySass = require(&apos;gulp-ruby-sass&apos;); gulp-load-plugins并不会一开始就加载所有package.json里的gulp插件，而是在我们需要用到某个插件的时候，才去加载那个插件。最后要提醒的一点是，因为gulp-load-plugins是通过你的package.json文件来加载插件的，所以必须要保证你需要自动加载的插件已经写入到了package.json文件里，并且这些插件都是已经安装好了的。 4.2 重命名使用gulp-rename安装：npm install --save-dev gulp-rename用来重命名文件流中的文件。用gulp.dest()方法写入文件时，文件名使用的是文件流中的文件名，如果要想改变文件名，那可以在之前用gulp-rename插件来改变文件流中的文件名。 1234567891011var gulp = require(&apos;gulp&apos;), rename = require(&apos;gulp-rename&apos;), uglify = require(&quot;gulp-uglify&quot;); gulp.task(&apos;rename&apos;, function () &#123; gulp.src(&apos;js/jquery.js&apos;) .pipe(uglify()) //压缩 .pipe(rename(&apos;jquery.min.js&apos;)) //会将jquery.js重命名为jquery.min.js .pipe(gulp.dest(&apos;js&apos;)); //关于gulp-rename的更多强大的用法请参考https://www.npmjs.com/package/gulp-rename&#125;); 4.3 js文件压缩使用gulp-uglify安装：npm install --save-dev gulp-uglify用来压缩js文件，使用的是uglify引擎 12345678var gulp = require(&apos;gulp&apos;), uglify = require(&quot;gulp-uglify&quot;); gulp.task(&apos;minify-js&apos;, function () &#123; gulp.src(&apos;js/*.js&apos;) // 要压缩的js文件 .pipe(uglify()) //使用uglify进行压缩,更多配置请参考： .pipe(gulp.dest(&apos;dist/js&apos;)); //压缩后的路径&#125;); 4.4 css文件压缩使用gulp-clean-css安装：npm install --save-dev gulp-clean-css要压缩css文件时可以使用该插件 12345678var gulp = require(&apos;gulp&apos;), minifyCss = require(&quot;gulp-clean-css&quot;); gulp.task(&apos;clean-css&apos;, function () &#123; gulp.src(&apos;css/*.css&apos;) // 要压缩的css文件 .pipe(minifyCss()) //压缩css .pipe(gulp.dest(&apos;dist/css&apos;));&#125;); 4.5 html文件压缩使用gulp-minify-html安装：npm install --save-dev gulp-minify-html用来压缩html文件 12345678var gulp = require(&apos;gulp&apos;), minifyHtml = require(&quot;gulp-minify-html&quot;); gulp.task(&apos;minify-html&apos;, function () &#123; gulp.src(&apos;html/*.html&apos;) // 要压缩的html文件 .pipe(minifyHtml()) //压缩 .pipe(gulp.dest(&apos;dist/html&apos;));&#125;); 4.6 js代码检查使用gulp-jshint安装：npm install --save-dev gulp-jshint用来检查js代码 12345678var gulp = require(&apos;gulp&apos;), jshint = require(&quot;gulp-jshint&quot;); gulp.task(&apos;jsLint&apos;, function () &#123; gulp.src(&apos;js/*.js&apos;) .pipe(jshint()) .pipe(jshint.reporter()); // 输出检查结果&#125;); 4.7 文件合并使用gulp-concat安装：npm install --save-dev gulp-concat用来把多个文件合并为一个文件,我们可以用它来合并js或css文件等，这样就能减少页面的http请求数了 12345678var gulp = require(&apos;gulp&apos;), concat = require(&quot;gulp-concat&quot;); gulp.task(&apos;concat&apos;, function () &#123; gulp.src(&apos;js/*.js&apos;) //要合并的文件 .pipe(concat(&apos;all.js&apos;)) // 合并匹配到的js文件并命名为 &quot;all.js&quot; .pipe(gulp.dest(&apos;dist/js&apos;));&#125;); 4.8 less和sass的编译less使用gulp-less,安装：npm install –save-dev gulp-less 12345678var gulp = require(&apos;gulp&apos;), less = require(&quot;gulp-less&quot;); gulp.task(&apos;compile-less&apos;, function () &#123; gulp.src(&apos;less/*.less&apos;) .pipe(less()) .pipe(gulp.dest(&apos;dist/css&apos;));&#125;); sass使用gulp-sass,安装：npm install --save-dev gulp-sass 12345678var gulp = require(&apos;gulp&apos;), sass = require(&quot;gulp-sass&quot;); gulp.task(&apos;compile-sass&apos;, function () &#123; gulp.src(&apos;sass/*.sass&apos;) .pipe(sass()) .pipe(gulp.dest(&apos;dist/css&apos;));&#125;); 4.9 图片压缩可以使用gulp-imagemin插件来压缩jpg、png、gif等图片。安装：npm install --save-dev gulp-imagemin 123456789101112var gulp = require(&apos;gulp&apos;);var imagemin = require(&apos;gulp-imagemin&apos;);var pngquant = require(&apos;imagemin-pngquant&apos;); //png图片压缩插件gulp.task(&apos;default&apos;, function () &#123; return gulp.src(&apos;src/images/*&apos;) .pipe(imagemin(&#123; progressive: true, use: [pngquant()] //使用pngquant来压缩png图片 &#125;)) .pipe(gulp.dest(&apos;dist&apos;));&#125;); gulp-imagemin的使用比较复杂一点，而且它本身也有很多插件，建议去它的项目主页看看文档 4.10 自动刷新使用gulp-livereload插件，安装:npm install --save-dev gulp-livereload。当代码变化时，它可以帮我们自动刷新页面该插件最好配合谷歌浏览器来使用，且要安装livereload chrome extension扩展插件,不能下载的请自行FQ。 123456789101112131415var gulp = require(&apos;gulp&apos;), less = require(&apos;gulp-less&apos;), livereload = require(&apos;gulp-livereload&apos;);gulp.task(&apos;less&apos;, function() &#123; gulp.src(&apos;less/*.less&apos;) .pipe(less()) .pipe(gulp.dest(&apos;css&apos;)) .pipe(livereload());&#125;);gulp.task(&apos;watch&apos;, function() &#123; livereload.listen(); //要在这里调用listen()方法 gulp.watch(&apos;less/*.less&apos;, [&apos;less&apos;]);&#125;);","tags":[{"name":"gulp","slug":"gulp","permalink":"http://ligoweb.com/tags/gulp/"}]},{"title":"hexo常用命令笔记","date":"2017-04-19T16:30:02.000Z","path":"2017/04/20/2017-4-20-hexo常用命令/","text":"hexo安装初始化123npm install hexo -g // 全局安装hexonpm update hexo -g // 升级hexohexo init // 初始化 简写命令hexo n “我的博客” == hexo new “我的博客” // 新建文章hexo p == hexo publishhexo g == hexo generate // 生成hexo s == hexo server // 启动服务预览hexo d == hexo deploy // 部署 服务器hexo server // hexo会监视文件变动并自动更新，无需启动服务器hexo server -s // 静态模式hexo server -p 5000 // 更改端口hexo server -i 192.168.1.1 // 自定义IP hexo clean // 清除缓存，网页正常情况下可以忽略此条命令hexo g // 生成静态网页hexo d // 开始部署 监视文件变动hexo generate // 使用Hexo生成静态文件快速而且简单hexo generate –watch // 监视文件变动 完成后部署 两个命令的作用是相同的hexo generate –deployhexo deploy –generate hexo deploy -ghexo server -g 草稿hexo publish [layout] 模板hexo new “postName” // 新建文章hexo new page “pageName” // 新建页面hexo generate // 生成静态页面至public目录hexo server // 开启预览访问端口（默认端口4000，‘ctrl+c’关闭server）hexo deploy // 讲.deploy目录部署到GitHub hexo new [layout] hexo new photo “XXX”hexo new “hello world” –lang en 变量 描述 layout 布局 title 标题 data 文件建立日期 12345678title: 使用Hexo搭建个人博客layout: postdate: 2017-04-20 19:07:43comments: truecategories: Blogtags: [Hexo]keywords: Hexo, Blogdescription: hexo博客 设置文章摘要 以上是文章摘要 &lt;！– more –&gt; 以下是余下全文 写作12hexo new page &lt;title&gt;hexo new post &lt;title&gt; 原文转摘：https://segmentfault.com/a/1190000002632530","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://ligoweb.com/tags/Hexo/"}]},{"title":"webpack学习笔记","date":"2017-04-04T03:49:34.000Z","path":"2017/04/04/2017-4-4-webpack学习笔记/","text":"webpack是当下最热门的前端资源模块化管理和打包工具，它能将各种资源，例如CommonJs模块、AMD模块、ES6模块、JSON、LESS/SESS、Vue等文件打包成符合生产环节部署的前端资源。webpack官网是：http://webpack.github.io webpack和gulp/grunt有什么区别gulp/grunt是一种能够优化前端开发流程的工具，而webpack是一种模块化的解决方案;gulp/grunt的工作方式是：在一个配置文件中，指明对某些文件进行编译、组合、压缩等任务的具体操作，这个工具之后能够自动替你完成这些任务，依赖各种相应的插件。 webpack工作流 webpack的工作方式是：把你的项目当做一个整体，通过给定的主文件（如index.js）,webpack将从这个文件开始找到你项目的所有依赖文件，使用loaders处理它们。最后打包为一个浏览器可以识别的javascript文件 webpack工作流 webpack的优势 webpack是以commonJS的形式书写脚本的，但对AMD/CMD的支持也很全面，方便旧项目进行代码迁移 能被模块化的不仅仅是JS 开发便捷，能替代部分grunt/gulp的工作，比如打包、压缩、图片转base64等 扩展性强，插件机制完善，支持热加载 webpack的安装使用12345678mkdir webpack-demo //新建webpack-deom文件夹cd webpack-demo //切换至该文件夹目录npm init -y //初始化npm install --save-dev webpack //安装webpackwebpack index.js build.js //将index.js文件打包后生成build.jsnpm install css-loader style-loader --save-dev //安装css文件支持和样式支持webpack index.js build.js --module-bind &apos;css=style-loader!css-loader&apos; //引入css模块进行打包webpack index.css build.js --module-bind &apos;css=style-loader!css-loader&apos; --watch //监视打包文件的改动实时编译 webpack.config.js配置 每个项目下都需配置一个默认的webpack.config.js文件，在命令行中执行webpack命令会自动执行webpack.config.js文件 12345678910var path = require(&apos;path&apos;)module.exports = &#123; entry: &apos;./src/script/main.js&apos;, // 入口文件 output: &#123; path: path.resolve(__dirname, &apos;./dist/js&apos;), filename: &apos;build.js&apos; &#125; // 打包后的路径及文件名&#125; entry和output entry是页面入口文件配置，可以支持多个入口文件output是对于的输出配置，如果filename指定文件名则打包成一个文件，如果加入[id]、[name]、[hash]、[chunckhash]则打包成多个对应的文件 123456789entry: &#123; home: &quot;./home.js&quot;, about: &quot;./about.js&quot;, contact: &quot;./contact.js&quot;&#125;,output: &#123; path: path.resolve(__dirname, &apos;./dist/js&apos;), filename: &quot;[name].build.js&quot;&#125;","tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://ligoweb.com/tags/Webpack/"}]},{"title":"nodeJs服务器建立","date":"2016-12-20T03:14:55.000Z","path":"2016/12/20/2016-12-20-nodeJS建立服务器/","text":"如何利用node.js创建一个简单的服务器并实现数据传输呢？ 1、创建app.js文件我们可以本地创建一个node文件夹，然后在该文件夹下先新建一个app.js文件,在app.js文件中编写以下代码： 12345678910111213141516// 引入node.js的http模块，并设置服务器地址和端口const http = require(&apos;http&apos;);const hostname = &apos;127.0.0.1&apos;const port = 3000;// 创建一个web服务器并根据相应状态返回相应值const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader(&apos;Content-Type&apos;, &apos;text/plain&apos;); res.end(&apos;Hello world\\n&apos;);&#125;);// 监听服务器端口并打印日志信息server.listen(port, hostname, () =&gt; &#123; console.log(&apos;Server running at http://$(hostname):$&#123;port&#125;/&apos;);&#125;); 在命令行中切换到node文件夹，使用node命令运行server.js文件 12$ node server.jsServer running at http://127.0.0.1:3000/","tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://ligoweb.com/tags/Node-js/"}]},{"title":"canvas","date":"2016-12-20T03:14:55.000Z","path":"2016/12/20/2016-12-20-canvas画图/","text":"什么是canvas?HTML5中新加入了元素标签用户图形的绘制，借助于javascript可以完成许多复杂图形的绘制工作。使用canvas可以从以下几个步骤入手： 1、创建一个画布通过在html中加入下列代码： 1&lt;canvas id=&apos;myCanvas&apos;&gt;&lt;/canvas&gt; 就可以建立一个画布canvas画布 2、javascript引入canvas绘图API1234var cav =document.getElementById(&apos;myCanvas&apos;); //通过id获取canvas对象var ctx=c.getContext(&apos;2d&apos;);//创建context，该对象为H5内置对象，拥有绘制API方法cav.width=300; //指定画布的宽度cav.heigth=300; //指定画布的高度 3、绘制路径在canvas画布中我们可以使用以下法进行路径线条的绘制： moveTo(x,y) 定义绘制线条的开始坐标 lineTo(x,y) 定义绘制线条的结束坐标 stroke() 调用绘制方法进行绘制 例 12345ctx.moveTo(100,100); //定于开始坐标ctx.lineTo(100,200); //定义结束坐标ctx.lineWidth=2; //定义线条宽度ctx.strokeStyle=&quot;#ffaadd&quot;; //定义线条颜色ctx.stroke(); //开始绘制 执行上述JS代码就会在画布上绘制一条直线，宽度为2px,线条颜色为粉红色 4、绘制弧形我们可以使用 arc(x,y,r,sAngle,eAngle,boole) x,y为弧形中心坐标，r会弧形半径，sAngle为绘制起始弧度角，eAngle为绘制结束弧度角，boole为可选参数，默认为false,顺时针绘制，设置true后将逆时针绘制。 例 1234ctx.art(100,100,100,0,2*Math.PI); //定义弧形绘制参数 ctx.lineWidth=5; //定义线条宽度ctx.strokeStyle=&quot;#ffaadd&quot;; //定义线条颜色ctx.stroke(); //开始绘制 执行上述JS代码就会在画布上绘制一个半径为100，线宽为5px,线条颜色为粉红色的圆。 5、绘制多个图形我们可以使用 beginPath() 该方法为重新起始一条绘制路径 例 1234567891011121314ctx.moveTo(50,100);ctx.lineTo(50,200);ctx.lineWidth=10;ctx.strokeStyle=&quot;#ffaa33&quot;;ctx.stroke();//绘制一条直线ctx.beginPath(); //重新起始一个绘制点ctx.arc(150,150,50,0,2*Math.PI);ctx.lineWidth=5;ctx.strokeStyle=&quot;#ffaadd&quot;;ctx.stroke();//绘制一个圆 6、进行颜色填充可以使用 fillStyle 定义填充的样式，包括颜色、渐变或模式 fill() 绘制完成后进行填充 例 12345678910111213141516ctx.moveTo(50,100);ctx.lineTo(50,200);ctx.lineWidth=10;ctx.strokeStyle=&quot;#ffaa33&quot;;ctx.stroke();//绘制一条直线ctx.beginPath(); //重新起始一个绘制点ctx.arc(150,150,50,0,2*Math.PI);ctx.lineWidth=10;ctx.strokeStyle=&quot;#ffaadd&quot;;ctx.stroke();//绘制一个圆ctx.fillStyle=&quot;#0000ff&quot;; //定义填充的颜色ctx.fill(); //开始填充 7、创建渐变可以使用 createLinearGradient(x0,y0,x1,y1) 创建线性渐变,x0,y0为渐变起始点坐标，x1,y1为渐变结束点坐标 createRadialGradient(x0,y0,r0,x1,y1,r1) 创建径向渐变,x0,y0,r0为渐变开始的圆的坐标及半径，x1,y1,r1为渐变结束的圆的坐标及半径 addColorStop(stop,color) 定义渐变位置及颜色stop为渐变的位置，介于0-1的数字，color为当前位置的颜色，可以设置多个addColoStop()方法以实现多种颜色之间的渐变 例 1234567891011121314151617181920212223242526var cav=document.getElementById(&apos;canvas&apos;); //获取canvas对象var ctx=canvas.getContext(&apos;2d&apos;); //引入canvasAPIvar clg=ctx.createLinearGradient(50,50,50,200); //创建线性渐变clg.addColorStop(0,&quot;#0a00b2&quot;); //0%位置的渐变颜色clg.addColorStop(0.5,&quot;#ff0000&quot;); //50%位置的渐变颜色clg.addColorStop(1,&quot;#fffc00&quot;); //100%位置的渐变颜色var crg=ctx.createRadialGradient(150,150,10,150,150,40); //创建径向渐变crg.addColorStop(0,&quot;red&quot;); //0%位置的渐变颜色crg.addColorStop(1,&quot;white&quot;); //100%位置的渐变颜色cav.width=300; //设置画布宽度cav.height=300; //设置画布高度 ctx.moveTo(50,50); //设置画笔起点 ctx.lineTo(50,200); //设置画笔终点ctx.lineWidth=10; //设置画笔大小ctx.strokeStyle=clg; //设置渐变方式ctx.stroke(); //开始绘制ctx.beginPath(); //开始另一个画笔起点ctx.arc(150,150,50,0,2*Math.PI); //设置弧形参数 ctx.lineWidth=10; //设置画笔大小ctx.strokeStyle=&quot;#ffaadd&quot;; //设置画笔颜色ctx.stroke(); //开始绘制ctx.fillStyle=crg; //设置填充渐变方式ctx.fill(); //开始填充 这些基本的方法就可以满足我们一些简单的图形绘制了，但是还有许多复杂的绘制API，利用这些方法我们还可以绘制更加复杂的图形，更多方法可以参考W3C规范","tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://ligoweb.com/tags/HTML5/"},{"name":"canvas","slug":"canvas","permalink":"http://ligoweb.com/tags/canvas/"}]},{"title":"Hexo默认端口","date":"2016-11-09T03:14:55.000Z","path":"2016/11/09/2016-11-09-heox默认端口/","text":"我们在使用hexo框架搭建个人博客时进行本地预览效果时通常是输入下面的指令 1$ hexo s 命令控制台会输出以下结果： 123$ hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 表示服务已经在4000端口开启，之后就可以在浏览器地址栏输入http://localhost:4000进行本地预览。但结果有时后浏览器会提示无法访问当前地址，这种情况大多数是因为4000端口被占用了，如果查看系统端口占用情况的话会看到有其它程序正在使用当前端口。针对这个问题我们有两种解决方案：1、临时修改服务端口指令 1$ hexo server -p 5000 这种方法可以将服务端口临时修改为5000端口，修改完之后就可以打开浏览器进入localhost:5000进行本地效果的预览。 2、修改hexo默认服务端口 我们进入到hexo根目录，找到node_modules文件夹，然后找到hexo-server文件夹，在该文件夹下找到配置文件进行修改，主要修改两个文件，一个是index.js文件，打开该文件后将里面的port参数修改为5000，另一个是lib文件夹下的server.js文件，同样的方法将原来的参数4000修改为5000，这样重新运行hexo就可以会将默认服务端口修改为5000。 123$ hexo sINFO Start processingINFO Hexo is running at http://localhost:5000/. Press Ctrl+C to stop. 这样每次重新部署时候，我们都可以进入浏览器在localhost:5000进行本地预览。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://ligoweb.com/tags/Hexo/"}]},{"title":"Hello World","date":"2016-10-11T03:07:41.000Z","path":"2016/10/11/2016-10-11-hello-world/","text":"Hello World By HexoWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://ligoweb.com/tags/Hexo/"}]}]